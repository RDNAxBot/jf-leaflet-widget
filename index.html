<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="initial-scale=1,width=device-width"/>
  <title>Leaflet Draw (WMS/WMTS) — Jotform Widget</title>

  <!-- Leaflet & Geoman CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-geoman-free@2.14.1/dist/leaflet-geoman.css"/>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .status { position:absolute; top:8px; left:8px; z-index:1000; background:rgba(255,255,255,.92);
      padding:6px 10px; border-radius:8px; font:13px/1.4 system-ui, Segoe UI, Roboto, sans-serif;
      box-shadow:0 2px 8px rgba(0,0,0,.08) }
    .ok{color:#0a7}.warn{color:#c80}.err{color:#c22}
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status" class="status ok">Loading…</div>

  <!-- Libraries -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-geoman-free@2.14.1/dist/leaflet-geoman.min.js"></script>
  <!-- Simple WMTS helper (tiny plugin) -->
  <script>
    // Minimal WMTS tile layer helper (for common XYZ-like templates)
    L.TileLayer.WMTS = L.TileLayer.extend({
      initialize: function(url, options) { L.TileLayer.prototype.initialize.call(this, url, options); }
    });
    L.tileLayer.wmts = function(url, options) { return new L.TileLayer.WMTS(url, options); };
  </script>

  <!-- Jotform Widget API -->
  <script src="https://js.jotform.com/JFCustomWidget.min.js"></script>

  <script>
    const $status = document.getElementById('status');
    const setStatus = (msg, cls='ok') => { $status.textContent = msg; $status.className = 'status '+cls; };

    // ----- Default settings (used for standalone preview) -----
    const defaultSettings = {
      center: [-31.9535, 115.8570], // Perth
      zoom: 14,
      allowShapes: ['polygon','rectangle','marker','polyline'],
      requireFeature: true,
      // WMS
      wmsUrl: '', wmsLayers: '', wmsFormat: 'image/png', wmsTransparent: false,
      // WMTS
      wmtsUrl: '', wmtsLayer: '', wmtsTileMatrixSet: '', wmtsFormat: 'image/png',
      fitBounds: ''
    };

    // ----- Build the map using provided settings -----
    function initMap(settings){
      const map = L.map('map').setView(settings.center, settings.zoom);

      // Basemap: prefer WMS, then WMTS, else OSM fallback (so it always shows something)
      let basemapAdded = false;

      if (settings.wmsUrl && settings.wmsLayers) {
        L.tileLayer.wms(settings.wmsUrl, {
          layers: settings.wmsLayers,
          format: settings.wmsFormat || 'image/png',
          transparent: !!settings.wmsTransparent,
          attribution: '© RocketDNA Ltd 2025'
        }).addTo(map);
        basemapAdded = true;
      } else if (settings.wmtsUrl && settings.wmtsLayer && settings.wmtsTileMatrixSet) {
        L.tileLayer.wmts(settings.wmtsUrl, {
          layer: settings.wmtsLayer,
          tilematrixSet: settings.wmtsTileMatrixSet,
          format: settings.wmtsFormat || 'image/png',
          attribution: '© RocketDNA Ltd 2025'
        }).addTo(map);
        basemapAdded = true;
      }

      if (!basemapAdded) {
        // Fallback while testing/previewing
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 20, attribution: '© OpenStreetMap'
        }).addTo(map);
        setStatus('Using OSM fallback (configure WMS/WMTS in widget settings).', 'warn');
      }

      // Optional: fit to supplied bounds "south,west,north,east"
      if (settings.fitBounds) {
        const parts = String(settings.fitBounds).split(',').map(Number);
        if (parts.length === 4 && parts.every(n=>!isNaN(n))) {
          const b = L.latLngBounds([parts[0], parts[1]], [parts[2], parts[3]]);
          map.fitBounds(b);
        }
      }

      // Drawing controls
      map.pm.addControls({
        position: 'topleft',
        drawMarker: settings.allowShapes.includes('marker'),
        drawPolyline: settings.allowShapes.includes('polyline'),
        drawRectangle: settings.allowShapes.includes('rectangle'),
        drawPolygon: settings.allowShapes.includes('polygon'),
        drawCircle: false, drawCircleMarker: false,
        editMode: true, dragMode: true, removalMode: true
      });

      function toFeature(layer){
        const gj = layer.toGeoJSON();
        return gj.type==='Feature' ? gj : { type:'Feature', geometry:gj, properties:{} };
      }

      function collectFC(){
        const features = [];
        map.eachLayer(l=>{
          // keep only drawn vector layers (basemaps don't have pm)
          if (l.pm && l.toGeoJSON && !l.getAttribution) {
            const f = toFeature(l);
            if (f.geometry && f.geometry.type) features.push(f);
          }
        });
        return { type:'FeatureCollection', features };
      }

      function validateFC(fc, requireFeature=true){
        if (requireFeature && (!fc.features || fc.features.length===0)) {
          return { ok:false, reason:'At least one shape is required.' };
        }
        return { ok:true };
      }

      function publish(){
        const fc = collectFC();
        // If running in Jotform, push the value; else just update status
        if (window.JFCustomWidget && typeof JFCustomWidget.setValue === 'function') {
          JFCustomWidget.setValue(JSON.stringify(fc));
        }
        const v = validateFC(fc, settings.requireFeature);
        setStatus(v.ok ? `Shapes: ${fc.features.length} (ready)` : `Validation: ${v.reason}`, v.ok?'ok':'warn');
      }

      // Restore existing value (if editing a submission inside Jotform)
      try {
        const initial = (window.JFCustomWidget && JFCustomWidget.getValue) ? JFCustomWidget.getValue() : null;
        if (initial) {
          const fc = JSON.parse(initial);
          L.geoJSON(fc).eachLayer(l => { l.addTo(map); if (l.pm) l.pm.enable(); });
          setStatus(`Loaded ${fc.features?.length||0} shape(s).`, 'ok');
        }
      } catch(e){/* ignore */ }

      map.on('pm:create', publish);
      map.on('pm:edit', publish);
      map.on('pm:remove', publish);
      publish();

      // Submit handshake (only meaningful inside Jotform)
      if (window.JFCustomWidget && typeof JFCustomWidget.subscribe === 'function') {
        JFCustomWidget.subscribe('submit', function(){
          const fc = collectFC();
          const v = validateFC(fc, settings.requireFeature);
          if (!v.ok) {
            setStatus(`Cannot submit: ${v.reason}`, 'err');
            JFCustomWidget.sendSubmit({ valid:false, value:JSON.stringify(fc), message:v.reason });
            return;
          }
          JFCustomWidget.sendSubmit({ valid:true, value:JSON.stringify(fc) });
        });
      }
    }

    // ----- Get settings from Jotform (if present) -----
    function readSettingsFromJotform(){
      const base = { ...defaultSettings };
      try {
        const s = (JFCustomWidget.getWidgetSetting && JFCustomWidget.getWidgetSetting()) || {};
        const num = (v, d) => isNaN(+v) ? d : +v;

        if (s.center) {
          const p = String(s.center).split(',').map(Number);
          if (p.length===2 && p.every(n=>!isNaN(n))) base.center = [p[0], p[1]];
        }
        base.zoom = num(s.zoom ?? base.zoom, base.zoom);
        base.allowShapes = String(s.allowShapes ?? base.allowShapes.join(',')).split(',').map(v=>v.trim());
        base.requireFeature = String(s.requireFeature ?? 'true').toLowerCase()==='true';

        base.wmsUrl = String(s.wmsUrl||'').trim();
        base.wmsLayers = String(s.wmsLayers||'').trim();
        base.wmsFormat = String(s.wmsFormat||'image/png').trim();
        base.wmsTransparent = String(s.wmsTransparent||'false').trim().toLowerCase()==='true';

        base.wmtsUrl = String(s.wmtsUrl||'').trim();
        base.wmtsLayer = String(s.wmtsLayer||'').trim();
        base.wmtsTileMatrixSet = String(s.wmtsTileMatrixSet||'').trim();
        base.wmtsFormat = String(s.wmtsFormat||'image/png').trim();

        base.fitBounds = String(s.fitBounds||'').trim();
      } catch(e) {
        console.warn('Settings parse error', e);
      }
      return base;
    }

    // ===== ENTRY POINTS =====
    if (window.JFCustomWidget && typeof JFCustomWidget.subscribe === 'function') {
      // Inside Jotform → wait for widget 'ready', then init with Jotform settings
      JFCustomWidget.subscribe('ready', function(){
        const jfSettings = readSettingsFromJotform();
        initMap(jfSettings);
      });
    } else {
      // Standalone (direct browser) → init immediately with defaults and OSM fallback
      document.addEventListener('DOMContentLoaded', function(){
        initMap(defaultSettings);
      });
    }
  </script>
</body>
</html>
