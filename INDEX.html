<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="initial-scale=1,width=device-width"/>
  <title>Leaflet Draw (WMS/WMTS) — Jotform Widget</title>

  <!-- Leaflet & Geoman CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-geoman-free@2.14.1/dist/leaflet-geoman.css"/>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .status { position:absolute; top:8px; left:8px; z-index:1000; background:rgba(255,255,255,.92);
      padding:6px 10px; border-radius:8px; font:13px/1.4 system-ui, Segoe UI, Roboto, sans-serif;
      box-shadow:0 2px 8px rgba(0,0,0,.08) }
    .ok{color:#0a7}.warn{color:#c80}.err{color:#c22}
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status" class="status ok">Loading…</div>

  <!-- Libraries -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-geoman-free@2.14.1/dist/leaflet-geoman.min.js"></script>
  <!-- Simple WMTS helper (tiny plugin) -->
  <script>
    // Minimal WMTS tile layer helper (for common XYZ-like templates)
    L.TileLayer.WMTS = L.TileLayer.extend({
      initialize: function(url, options) { L.TileLayer.prototype.initialize.call(this, url, options); }
    });
    L.tileLayer.wmts = function(url, options) { return new L.TileLayer.WMTS(url, options); };
  </script>

  <!-- Jotform Widget API -->
  <script src="https://js.jotform.com/JFCustomWidget.min.js"></script>

  <script>
    const $status = document.getElementById('status');
    const setStatus = (msg, cls='ok') => { $status.textContent = msg; $status.className = 'status '+cls; };

    let settings = {
      center: [-31.9535, 115.8570],
      zoom: 14,
      allowShapes: ['polygon','rectangle','marker','polyline'],
      requireFeature: true,
      // WMS
      wmsUrl: '', wmsLayers: '', wmsFormat: 'image/png', wmsTransparent: 'false',
      // WMTS
      wmtsUrl: '', wmtsLayer: '', wmtsTileMatrixSet: '', wmtsFormat: 'image/png',
      fitBounds: ''
    };

    function parseSettings(){
      const s = (JFCustomWidget.getWidgetSetting && JFCustomWidget.getWidgetSetting()) || {};
      const num = (v, d) => isNaN(+v) ? d : +v;

      if (s.center) {
        const p = String(s.center).split(',').map(Number);
        if (p.length===2 && p.every(n=>!isNaN(n))) settings.center = [p[0], p[1]];
      }
      settings.zoom = num(s.zoom ?? settings.zoom, settings.zoom);
      settings.allowShapes = String(s.allowShapes ?? settings.allowShapes.join(',')).split(',').map(v=>v.trim());
      settings.requireFeature = String(s.requireFeature ?? 'true').toLowerCase()==='true';

      settings.wmsUrl = String(s.wmsUrl||'').trim();
      settings.wmsLayers = String(s.wmsLayers||'').trim();
      settings.wmsFormat = String(s.wmsFormat||'image/png').trim();
      settings.wmsTransparent = String(s.wmsTransparent||'false').trim().toLowerCase()==='true';

      settings.wmtsUrl = String(s.wmtsUrl||'').trim();
      settings.wmtsLayer = String(s.wmtsLayer||'').trim();
      settings.wmtsTileMatrixSet = String(s.wmtsTileMatrixSet||'').trim();
      settings.wmtsFormat = String(s.wmtsFormat||'image/png').trim();

      settings.fitBounds = String(s.fitBounds||'').trim();
    }

    function toFeature(layer){
      const gj = layer.toGeoJSON();
      return gj.type==='Feature' ? gj : { type:'Feature', geometry:gj, properties:{} };
    }

    function collectFC(map){
      const features = [];
      map.eachLayer(l=>{
        // keep only drawn vector layers (wm*s and basemap layers don't have pm)
        if (l.pm && l.toGeoJSON && !l.getAttribution) {
          const f = toFeature(l);
          if (f.geometry && f.geometry.type) features.push(f);
        }
      });
      return { type:'FeatureCollection', features };
    }

    function validateFC(fc){
      if (settings.requireFeature && (!fc.features || fc.features.length===0)) {
        return { ok:false, reason:'At least one shape is required.' };
      }
      return { ok:true };
    }

    JFCustomWidget.subscribe('ready', function(){
      parseSettings();

      const map = L.map('map').setView(settings.center, settings.zoom);

      // --- Basemap selection: prefer WMS if provided, else WMTS ---
      if (settings.wmsUrl && settings.wmsLayers) {
        L.tileLayer.wms(settings.wmsUrl, {
          layers: settings.wmsLayers,
          format: settings.wmsFormat,
          transparent: settings.wmsTransparent,
          attribution: '© RocketDNA Ltd 2025'
        }).addTo(map);
      } else if (settings.wmtsUrl && settings.wmtsLayer && settings.wmtsTileMatrixSet) {
        // Common WMTS templates look like:
        // https://server/wmts/{layer}/{TileMatrixSet}/{z}/{y}/{x}.png   (varies by server)
        L.tileLayer.wmts(settings.wmtsUrl, {
          layer: settings.wmtsLayer,
          tilematrixSet: settings.wmtsTileMatrixSet,
          format: settings.wmtsFormat,
          attribution: '© RocketDNA Ltd 2025'
        }).addTo(map);
      } else {
        setStatus('No WMS/WMTS configured. Please fill widget settings.', 'warn');
      }

      // Optional: fit to supplied bounds "south,west,north,east"
      if (settings.fitBounds) {
        const parts = settings.fitBounds.split(',').map(Number);
        if (parts.length === 4 && parts.every(n=>!isNaN(n))) {
          const b = L.latLngBounds([parts[0], parts[1]], [parts[2], parts[3]]);
          map.fitBounds(b);
        }
      }

      // Drawing controls
      map.pm.addControls({
        position: 'topleft',
        drawMarker: settings.allowShapes.includes('marker'),
        drawPolyline: settings.allowShapes.includes('polyline'),
        drawRectangle: settings.allowShapes.includes('rectangle'),
        drawPolygon: settings.allowShapes.includes('polygon'),
        drawCircle: false, drawCircleMarker: false,
        editMode: true, dragMode: true, removalMode: true
      });

      function publish(){
        const fc = collectFC(map);
        JFCustomWidget.setValue(JSON.stringify(fc));
        const v = validateFC(fc);
        setStatus(v.ok ? `Shapes: ${fc.features.length} (ready)` : `Validation: ${v.reason}`, v.ok?'ok':'warn');
      }

      // Restore existing value (if editing submission)
      try {
        const initial = JFCustomWidget.getValue && JFCustomWidget.getValue();
        if (initial) {
          const fc = JSON.parse(initial);
          L.geoJSON(fc).eachLayer(l => { l.addTo(map); if (l.pm) l.pm.enable(); });
          setStatus(`Loaded ${fc.features?.length||0} shape(s).`, 'ok');
        }
      } catch(e){/* ignore */ }

      map.on('pm:create', publish);
      map.on('pm:edit', publish);
      map.on('pm:remove', publish);
      publish();

      // Submit handshake
      JFCustomWidget.subscribe('submit', function(){
        const fc = collectFC(map);
        const v = validateFC(fc);
        if (!v.ok) {
          setStatus(`Cannot submit: ${v.reason}`, 'err');
          JFCustomWidget.sendSubmit({ valid:false, value:JSON.stringify(fc), message:v.reason });
          return;
        }
        JFCustomWidget.sendSubmit({ valid:true, value:JSON.stringify(fc) });
      });
    });
  </script>
</body>
</html>
